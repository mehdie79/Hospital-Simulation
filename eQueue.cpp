#include "eQueue.h"
#include "pQueue.h"
#include "main.h"
#include <iostream>
#include <algorithm>
#include <utility>
using namespace std;

eQueue::~eQueue()
{
    for (int i = 0; i < (int) container.size(); i++)
        free(container[i]);
}
// This comparator is used to sort the node generated by the arrival time
bool comparator(QueueNode *l, QueueNode *r)
{
    return (l->arrival_time < r->arrival_time);
}

eQueue::eQueue(int seed, double arrivalHigh, double arrivalMedium, double arrivalLow, double mu, int r, double max_time) : Queue(r)
{
    srand((unsigned)seed);
    double current_time = 0;
    // Generate three sequences of arrivals; one of each priority
    // Generating sequence of arrivals having high priority
    while (current_time < max_time)
    {
        if (current_time != 0)
            container.push_back(CreateQueueNode(current_time, -1, 1));
        current_time += possion(arrivalHigh);
    }
    current_time = 0;
    // Generating sequence of arrivals having medium priority
    while (current_time < max_time)
    {
        if (current_time != 0)
            container.push_back(CreateQueueNode(current_time, -1, 2));
        current_time += possion(arrivalMedium);
    }
    current_time = 0;
    // Generating sequence of arrivals having low priority
    while (current_time < max_time)
    {
        if (current_time != 0)
            container.push_back(CreateQueueNode(current_time, -1, 3));
        current_time += possion(arrivalLow);
    }
    //merge three time sequences into one using comparator
    //store them in container to free them later in the destructor
    sort(container.begin(), container.end(), comparator);
    //index the nodes according to their arrival time
    for (int i = 0; i < (int) container.size(); i++)
    {
        container[i]->index = i;
    }
    
    // Initialize the free server deque by pushing numbers from 0 to server_number-1
    // Free server help us to track the available servers (nurses) in the "E" queue
    for (int k =0; k < r; k++)
    {
        free_server.push_back(k);
    }
    this->mu = mu;
    // Initialize Equeue last event
    last_event_equeue = 0;
    // insert first arrival into the event list
    event_queue->InsertEventNode(1, container.front()->arrival_time, container.front(), -1, 1); // 1 means arrival, -1 means position unknown,1 means stage1
}

void eQueue::ProcessArrival(struct QueueNode *elementQ) // waiting  queue
{
    // if there are still patients, schedule arrival of next patient no matter the hospital is full or not
    // 1 means arrival, -1 means position unknown,1 means stage1
    if (elementQ->index != (int) container.size() - 1)
        event_queue->InsertEventNode(1, container[elementQ->index + 1]->arrival_time, container[elementQ->index + 1], -1, 1);

    // if the hosptial is full, reject the patient by doing nothing
    if (event_queue->buffer_capacity == event_queue->counter)
    {
        total_number_patients_fullCapcity++;
        return;
    }
    
    // if the hopitial is not full, total element in stage1 +1
    current_number++;

    event_queue->counter++; // Total elements in system + 1
    if(free_server.size() > 0)
    {
        int temp = free_server.front();
        free_server.pop_front();
        ProcessStartService(elementQ, temp);
    }
    else
    {
        current_waiting++; 
        // Return the free server into the system
        waiting_queue.push_back(elementQ);
    }
    
}
void eQueue::ProcessStartService(struct QueueNode *elementQ, int position)
{
    // Schedule the endservice at stage 1 (possion(mu): generates the service time of stage 1)
    event_queue->InsertEventNode(4, event_queue->current_time + possion(mu), elementQ, position, 1); 
}
void eQueue::ProcessEndService(struct QueueNode *elementQ, int position) {}
void eQueue::ProcessDeparture(struct QueueNode *elementQ, int position)
{
    
    departure_count++;
    current_number--; // decrement total element in the system
    // refresh the arrival time for next stage
    elementQ->arrival_time = event_queue->current_time;
    // 1 means arrival 2 means the event is for stage2
    event_queue->InsertEventNode(1, event_queue->current_time, elementQ, position, 2); 
    if (current_waiting > 0)
    {
        current_waiting--;
        // Get the head customer at the waiting queue
        QueueNode *t = waiting_queue.front();
        waiting_queue.pop_front();
        ProcessStartService(t, position);
    } else{
        // Return the server into the system
        free_server.push_back(position);
    }
}
